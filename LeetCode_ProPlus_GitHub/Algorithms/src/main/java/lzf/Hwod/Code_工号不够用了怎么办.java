package lzf.Hwod;

/**
 * https://blog.csdn.net/csfun1/article/details/124390802?spm=1001.2014.3001.5502
 * 3020年，空间通信集团的员工人数突破20亿人，即将遇到现有工号不够用的窘境。
 * 现在，请你负责调研新工号系统。继承历史传统，新的工号系统由小写英文字母（a-z）和数字（0-9）两部分构成。新工号由一段英文字母开头，
 * 之后跟随一段数字，比如"aaahw0001",“a12345”,“abcd1”,“a00”。注意新工号不能全为字母或者数字,允许数字部分有前导0或者全为0。
 * 但是过长的工号会增加同事们的记忆成本，现在给出新工号至少需要分配的人数X和新工号中字母的长度Y，求新工号中数字的最短长度Z。
 * 输入描述:
 * 一行两个非负整数 X Y，用数字用单个空格分隔。
 * 0< X <=2^50 - 1
 * 0< Y <=5
 * 输出描述:
 * 输出新工号中数字的最短长度Z
 * 示例1
 * 输入
 * 260 1
 * 输出
 * 1
 * 示例2
 * 输入
 * 26 1
 * 输出
 * 1
 * 说明
 * 数字长度不能为0
 * 示例3
 * 输入
 * 2600 1
 * 输出
 * 2
 */
public class Code_工号不够用了怎么办 {
    public static void main(String[] args) {
        int x = 2600,y=1;
        System.out.println(getWorkNum(x,y));
    }

    private static int getWorkNum(int x, int y) {
        if (x<=26){
            // 如果所需人数少于26人，那么工牌的数字长度最多不超过1即可，因为题目要求不能纯数字或纯字
            //母，因此长度至少为1
            return 1;
        }
        // 用del表示可能的情况数
        int del = 1;
        // 当字母长度为1时，因为字母总共有26个，因此初始的仅凭给定的字母可以拼凑的情况有26种。
        // 注意：假如给定的字母长度不为1，那么可以拼凑的情况应该是del = del * 26,因为一个字母跟
        // 另一个字母拼接有26种情况，26个字母那么就是有26*26种情况，以此类推。
        for (int i = 0; i < y; i++) {
            del = del * 26;
        }
        // 用r来表示数字的长度。
        int r = 1;
        // 上面的到的del是还没有跟数字进行拼接的，因此这里将数字初始值长度设置为1，长度为1的数字跟
        // 上面得到的字母情况del拼接，因为数字为0-9总共有10个，因此得到的一个数字长度跟字母拼接
        // 的总共情况为del*10。
        del *=10;
        // 判断得到的情况，也即工号数量是否符合题目要求，如果不满足，说明还需要继续添加数字进行拼接，
        // 因此需要将数字长度r++,通过while循环不断进行判断,判断添加了多一个数字长度得到的工号数量
        // 是否满足要求,如果满足,就退出循环,返回r即为工号最少需要的数字长度
        while (del<x){
            del *=10;
            r++;
        }
        return r;
    }
}
